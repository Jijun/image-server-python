#!/usr/bin/env python# -*- coding: utf-8 -*-from __future__ import divisionimport mathimport itertools__author__ = 'tyk'def is_prime(number):    if number > 1:        if number == 2:            return True        if number % 2 == 0:            return False        for current in range(3, int(math.sqrt(number) + 1), 2):            if number % current == 0:                return False        return True    return Falsedef prime(start, end):    n = start    while n < end:        if is_prime(n):            yield n        n += 1g = prime(1, 1000000000)# print sum(g)# def prime_2(max):# for num in itertools.count(1):#         if num > max:#             break#     if is_prime(num):#         yield num## gg = prime(1000000000)# gg.next()import osfrom multiprocessing import Pool, Process, cpu_countdef sum_prime(start, end):    print start, end    g = prime(start, end)    print sum(g)def count(max):    cpus = cpu_count() - 1    base = int(round(max / cpus))    # for i in range(0, cpus):        # print 'Parent process %s.' % os.getpid()        # p = Process(target=sum_prime, args=(base * i, min(base * (i + 1), max)))        # print 'Process will start.'        # p.start()        # # p.join()        # print 'Process end.'        #    print 'Parent process %s.' % os.getpid()    p = Pool()    for i in range(0, cpus):        p.apply_async(sum_prime, args=(base * i, min(base * (i + 1), max)))    print 'Waiting for all subprocesses done...'    p.close()    p.join()    print 'All subprocesses done.'if __name__ == '__main__':    count(1000000000)